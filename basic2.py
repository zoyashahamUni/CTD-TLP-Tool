"""
The script uses CTD pairwise testing and finds feasible tests using the nuXmv model.
It generates LTL formula based each time on different pairs as the basis in order to cover all pairs.
How is it done?
1. It reads two files: factors.json and model.smv
    - factors.json - that includes which factors exist in the system and how the LTL formula looks like.
    - model.smv - The set of rules that exist in our testing system.
        **factors - the logical properties in the system - the ones that we're testing

2. The system creates all CTD pairs of the factors. The list is called "todo" 
    e.g. - if there are 3 factors:a,b,c there will be a list of all possible values of all possible factors.
    There will be a full list of (a,b), (b,c), (a,c) values.

3. While the todo is not empty:
    1. Pick randomly one pair from the todo
    2. Ask nuXmv if there is a trace that satisfies this pair
        1. If no - the pair will be marked as infeasible and will be removed from the todo list
        2. If yes - it means a trace of test steps (ST) exists and it is represented in the feasible row:
            1. Extract from the nuXmv response the full row's factors' values
            2. write down the suggested ST (test steps) (TBD)
            3. removes from the todo all the CTD pairs that this row satisfies (feasible pairs)
4. print all generated feasible rows            
"""
import json, subprocess, tempfile, os, re, random
from itertools import combinations
from pathlib import Path


# config

MODEL_PATH = "examples/shopping/model.smv"
FACTORS_PATH = "examples/shopping/factors.json"

#parse the output trace that is generated by nuXmv
STATE_RE = re.compile(r"^\s*-> State:")
ASSIGN_RE = re.compile(r"^\s*([A-Za-z0-9_]+)\s*=\s*(.+?)\s*$")

#read the factors.json file and transform the factors list to a dictionary
def load_cfg(path):
    with open(path) as f:
        d = json.load(f)
    return {
        "factors": {x["name"]: x for x in d["factors"]},
        "tmpl": d["ltl_template"],
        "end": d["end_flag"],
    }

#Create all the CTD pairs combinations of the factor values
def all_pairs(factors):
    names = list(factors)
    ps = set()
    for f1, f2 in combinations(names, 2):
        for v1 in factors[f1]["values"]:
            for v2 in factors[f2]["values"]:
                ps.add(((f1, v1), (f2, v2)))
    return ps

#Build the individual factor constraint to use in phi_for_pair
def cond(name, val, cfg):
    e = cfg["factors"][name]
    v = "TRUE" if val is True else "FALSE" if val is False else str(val)
    return f"({e['smv_var']} = {v})"

#Build the LTL property for a given CTD pair
def phi_for_pair(pair, cfg):
    (f1, v1), (f2, v2) = pair
    cs = [cond(f1, v1, cfg), cond(f2, v2, cfg)]
    
    # To use only the integer values we declared we want to test in the factors.json file
    for name, e in cfg["factors"].items():
        vs = e["values"]
        if vs and all(isinstance(x, int) and not isinstance(x, bool) for x in vs):
            d = " | ".join(f"{e['smv_var']} = {x}" for x in vs)
            cs.append(f"({d})")
    joined = " & ".join(f"({c})" for c in cs)
    return cfg["tmpl"].replace("{conditions}", joined)

#Call nuXmv with the not(generated LTL property) and return the counter example output which means that the row is feasible
def run_nuxmv(model, phi):
    script = f"read_model -i {model}\ngo\ncheck_ltlspec -p \"!( {phi} )\"\nshow_traces -a -v\nquit\n" #The script that runs the nuXmv
    
    # make sure the temp file is cleaned
    with tempfile.NamedTemporaryFile("w", suffix=".cmd", delete=False) as f:
        f.write(script)
        cmd = f.name
    try:
        #for cleanup consistency using the Path
        out = subprocess.run(["nuXmv", "-source", cmd],
                             capture_output=True, text=True).stdout
    finally:
        try: os.remove(cmd)
        except OSError: pass
    return out if "is false" in out else None

#Extract the entire set of factor values that exist when end_State==True
def extract_row(stdout, cfg):
    end_flag = cfg["end"]
    facs = cfg["factors"]
    state, last = {}, None
    for line in stdout.splitlines():
        if STATE_RE.match(line):
            if state.get(end_flag) == "TRUE":
                last = state.copy()
            state = {}
            continue
        m = ASSIGN_RE.match(line)
        if m:
            state[m.group(1)] = m.group(2).strip()
    if state.get(end_flag) == "TRUE":
        last = state
    if last is None:
        return None
    row = {}
    for name, e in facs.items():
        raw = last.get(e["smv_var"])
        if raw is None: return None
        vs = e["values"]
        if all(isinstance(v, bool) for v in vs):
            row[name] = (raw.upper() == "TRUE")
        else:
            row[name] = int(raw)
    return row

#Runs nuXmv for a pair according to the model and calls the extract_row to figure out what is the entire set of factor values for this specific row
def test_for_pair(pair, cfg, model):
    out = run_nuxmv(model, phi_for_pair(pair, cfg))
    return extract_row(out, cfg) if out else None

#Checks if a rest row satisfies the given CTD pair
def row_satisfies(row, pair):
    (f1, v1), (f2, v2) = pair
    return row[f1] == v1 and row[f2] == v2

#Sets up the data structures that are needed to implement the algorithm
#It loads the configuration from factors.json
#using the todo list to check the pairs that appear there
#Either they'll be infeasible or feasible - in both cases they'll be removed from the todo. 
# If they're infeasible - they'll be moved to a specific list, so we'll not use them again while building the other rows
def gen_tests(model_path, factors_path):
    cfg = load_cfg(factors_path)
    pairs = all_pairs(cfg["factors"])
    todo = set(pairs)
    tests, infeasible = [], set()
    while todo:
        pair = random.choice(tuple(todo))
        row = test_for_pair(pair, cfg, model_path)
        if row is None:
            infeasible.add(pair)
            todo.remove(pair)
            continue
        tests.append(row)
        for p in list(todo):
            if row_satisfies(row, p):
                todo.remove(p)
    return tests, infeasible, pairs

#The beginning
def main():
    model = str(Path(MODEL_PATH).resolve())
    factors = str(Path(FACTORS_PATH).resolve())
    tests, infeasible, pairs = gen_tests(model, factors)
    
    #Prints the tests that we need to run
    print("Generated tests:")
    for i,t in enumerate(tests, start=1):
        print(f" Test {i}: {t}")
    
    #Print the infeasible pairs
    print("\nInfeasible CTD pairs:")
    if infeasible:
        for p in infeasible:
            print(" ", p)
    else:
        print("  (none)")
    print(f"\nTotal CTD pairs:     {len(pairs)}")
    print(f"Feasible CTD pairs:  {len(pairs) - len(infeasible)}")
    print(f"Infeasible CTD pairs:{len(infeasible)}")

if __name__ == "__main__":
    main()
