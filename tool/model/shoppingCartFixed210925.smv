MODULE main

VAR
    --Abstract system state
    mode : {LoggedOut, Shopping, CheckedOut};
    items : 0..5;

    -- A: number of logouts before checkout
    logout_count : 0..5;        -- cap at 5 to keep state finite

    -- B: maximum cart size ever reached so far (entire run)
    max_items : 0..5;

    -- C: action tracking for remove/alternation logic
    seen_add    : boolean;      -- have we seen any Add so far?
    removed_ever: boolean;      -- have we seen any Remove so far?
    removed_after_add : boolean;-- have we removed at least once after an Add?
    enforce_profile : boolean;  -- progress switch (enforce until goal is reached)
    
    step: {Login, Logout, Add, Remove, Checkout, Idle};

ASSIGN
    init(mode) := LoggedOut;
    init(items) := 0;

    
    init(logout_count)      := 0;
    init(max_items)         := 0;
    
    init(seen_add)          := FALSE;
    init(removed_ever)      := FALSE;
    init(removed_after_add) := FALSE;
    init(enforce_profile)   := FALSE;
 
    next(mode) := case
      -- after a checkout, go back to Shopping (new cycle)
      mode = CheckedOut                      : Shopping;

      -- allow staying LoggedOut or logging in
      mode = LoggedOut                       : {LoggedOut, Shopping};

      -- while Shopping, you may checkout (if cart has items) or keep shopping
      mode = Shopping & items > 0            : {CheckedOut, Shopping};

      -- while Shopping with empty cart, you may stay or log out
      mode = Shopping & items = 0            : {Shopping, LoggedOut};

      TRUE : mode;
    esac;

    next(items) := case
            -- reset on checkout
            mode = Shopping & next(mode) = CheckedOut : 0;

            -- reset to 0 when going to LoggedOut (clear cart on logout)
            next(mode) = LoggedOut                    : 0;

            -- while shopping, allow add/remove/idle within bounds
            mode = Shopping & items = 0               : {items + 1, items};
            mode = Shopping & items = 5               : {items - 1, items};
            mode = Shopping & items > 0 & items < 5   : {items - 1, items + 1, items};

            -- otherwise unchanged (e.g., when LoggedOut or CheckedOut)
            TRUE : items;
        esac;

    --count logouts
    next(logout_count) := case
        -- count a logout when we move from Shopping to LoggedOut
        mode = Shopping & next(mode) = LoggedOut & logout_count < 5 : logout_count + 1;
        --mode = Shopping & next(mode) = LoggedOut & logout_count = 5 : 5;
        TRUE : logout_count;
    esac;

    --Tracking maximum cart size seen so far
    next(max_items) :=case
        next(items) > max_items : next(items);  -- monotone: keep the max
        TRUE : max_items;
    esac;

    -- Have we ever added?
    next(seen_add) := case
      (mode = Shopping) & (next(mode) = Shopping) & (next(items) = items + 1) : TRUE;
      TRUE   : seen_add;
    esac;

    -- Have we ever removed?
    next(removed_ever) := case
      (mode = Shopping) & (next(mode) = Shopping) & (next(items) = items - 1) : TRUE;
      TRUE      : removed_ever;
    esac;

    -- Have we removed at least once after an Add occurred earlier?
    next(removed_after_add) := case
      seen_add & (mode = Shopping) & (next(mode) = Shopping) & (next(items) = items - 1) : TRUE;
      TRUE                 : removed_after_add;
    esac;

    -- stop enforcing once the goal state is reached
    next(enforce_profile) := enforce_profile & !(mode = CheckedOut & a & b & c);
    
    
DEFINE
  -- step detectors (for witness -> ST)
  do_login    := (mode = LoggedOut) & (next(mode) = Shopping);
  do_logout   := (mode = Shopping)  & (next(mode) = LoggedOut);
  do_checkout := (mode = Shopping)  & (items > 0) & (next(mode) = CheckedOut);
  do_add      := (mode = Shopping)  & (next(mode) = Shopping) & (next(items) = items + 1);
  do_remove   := (mode = Shopping)  & (next(mode) = Shopping) & (next(items) = items - 1);

  -- Numeric label for easy scripted-test extraction from witness traces
  step_label :=
    case
      do_login    : Login;   -- Login
      do_add      : Add;   -- Add
      do_remove   : Remove;   -- Remove
      do_checkout : Checkout;
      do_logout   : Logout;
      TRUE        : Idle;
    esac;

  -- Boolean CTD profiles (A,B,C ∈ {0,1})
  a := (logout_count = 0);   -- no logout
  b := (max_items    = 5);   
  c := !removed_ever;        -- no remove ever happened

 -- Progress: forbid infinite “idle” while items < 5
TRANS !(mode = Shopping & items < 5 & next(items) = items)
 

--LTLSPEC F (mode = CheckedOut)
--LTLSPEC G (do_add -> X !do_remove) --no remove immediately after add

-- CTD rows (A,B,C ∈ {0,1}); run one per row to get an (ST):
--LTLSPEC F (a  &  b  &  c  )  -- Row A=1,B=1,C=1
--LTLSPEC F (mode = CheckedOut &  a  & !b  &  c  )  -- Row A=1,B=0,C=1
--LTLSPEC F (mode = CheckedOut & !a  &  b  & !c )  -- Row A=0,B=1,C=0

 -- Progress constraints (only while enforce_profile = TRUE)
--TRANS !(enforce_profile & do_remove)                                            -- no remove
--TRANS !(enforce_profile & do_logout)                                            -- no logout
--TRANS !(enforce_profile & mode = LoggedOut & next(mode) = LoggedOut)            -- must login
--TRANS !(enforce_profile & mode = Shopping & items < 5 & next(items) != items + 1) -- must add up to 5
--TRANS !(enforce_profile & mode = Shopping & items = 5 & next(mode) != CheckedOut) -- must checkout at 5

-- Forced eventuality goal
LTLSPEC !F (mode = CheckedOut & a & b & c)
