MODULE main

VAR
    mode : {LoggedOut, Shopping, CheckedOut};
    items : 0..5;

    -- A: number of logouts before checkout
    logout_count : 0..5;        -- cap at 5 just to keep state finite

    -- B: maximum cart size ever reached so far (entire run)
    max_items : 0..5;

    -- C: action tracking for remove/alternation logic
    last_action : {None, Add, Remove};
    alt_steps   : 0..2;         -- 0: none/one kind; 1: one alternation; 2: two-or-more alternations
    seen_add    : boolean;      -- have we seen any Add so far?
    removed_ever: boolean;      -- have we seen any Remove so far?
    removed_after_add : boolean;-- have we removed at least once after an Add?
    last : {None, Login, Add, Remove, Checkout, Logout};
    -- have we reached a checkout yet?
    checked_once : boolean;

    -- ST driver (explicit test steps)
    step : 0..20;                         -- how many test steps (adjust upper bound as needed)
    act  : {Idle, Login, AddAct, RemoveAct, CheckoutAct, LogoutAct};

FROZENVAR
-- test profile: A1 (no logout before first checkout)
    selA1 : boolean;

    -- test profile: B1 (cart always empty before first checkout)
    selB1 : boolean; 

    -- test profile: C1 (no remove before first checkout)
    selC1 : boolean;

    -- single toggle for Scripted Test mode
    USE_SCRIPT : boolean;   


ASSIGN
    init(mode) := LoggedOut;
    init(items) := 0;

    
    init(logout_count)      := 0;
    init(max_items)         := 0;
    init(last_action)       := None;
    init(alt_steps)         := 0;
    init(seen_add)          := FALSE;
    init(removed_ever)      := FALSE;
    init(removed_after_add) := FALSE;
    init(checked_once) := FALSE;
  
    -- toggle these TRUE/FALSE per test profile
    init(selA1) := TRUE;  
    init(selB1) := TRUE;
    init(selC1) := TRUE;
    init(last) := None;
    next(last) := case
        USE_SCRIPT & (act = Login)       & ST_Login    : Login;
        USE_SCRIPT & (act = AddAct)      & ST_Add      : Add;
        USE_SCRIPT & (act = RemoveAct)   & ST_Remove   : Remove;
        USE_SCRIPT & (act = CheckoutAct) & ST_Checkout : Checkout;
        USE_SCRIPT & (act = LogoutAct)   & ST_Logout   : Logout;
        TRUE                                              : last;
    esac;
    -- ST: default OFF; set TRUE when you want explicit steps
    init(USE_SCRIPT) := TRUE;


    -- ST: start at step 0 with a first action
    init(step) := 0;
    init(act)  := Idle;

    -- ST: advance the step counter only when scripted and before first checkout
    next(step) := case
        USE_SCRIPT & step < 20 & !checked_once : step + 1;
        TRUE                                  : step;
    esac;

    -- ST: define the action at each step (example script; edit as you like)
    next(act) := case
        !USE_SCRIPT                        : act;          -- ignore when scripting is off
        step = 0                         : Login;        -- ST1: login
        step = 1                         : AddAct;       -- ST2: add
        step = 2                         : CheckoutAct;  -- ST3: checkout
        TRUE                             : Idle;         -- then idle
    esac;

    next(checked_once) := checked_once | (mode = Shopping & next(mode) = CheckedOut);

    next(mode) := case
        -- When scripted, drive mode by act (deterministic)
        USE_SCRIPT : case
            act = Login      & mode = LoggedOut                     : Shopping;
            act = LogoutAct  & mode = Shopping                      : LoggedOut;
            act = CheckoutAct & mode = Shopping & items > 0         : CheckedOut;
            TRUE                                                   : mode;  -- otherwise hold
        esac;

        -- Otherwise, use your original non-deterministic rules
        TRUE : case
            -- after a checkout, go back to Shopping (new cycle)
            mode = CheckedOut                      : Shopping;

            -- allow staying LoggedOut or logging in
            mode = LoggedOut                       : {LoggedOut, Shopping};

            -- while Shopping, you may checkout (if cart has items) or keep shopping
            mode = Shopping & items > 0            : {CheckedOut, Shopping};

            -- while Shopping with empty cart, you may stay or log out
            mode = Shopping & items = 0            : {Shopping, LoggedOut};

            TRUE : mode;
        esac;
    esac;

    next(items) := case
        -- When scripted, drive items by act
        USE_SCRIPT : case
            act = AddAct     & mode = Shopping & items < 5          : items + 1;
            act = RemoveAct  & mode = Shopping & items > 0          : items - 1;
            act = CheckoutAct                                         : 0;   -- reset on checkout
            act = LogoutAct                                           : 0;   -- clear on logout (matches your policy)
            TRUE                                                     : items;
        esac;

        -- Otherwise, your original non-deterministic rules
        TRUE : case
            -- reset on checkout
            mode = Shopping & next(mode) = CheckedOut : 0;

            -- reset to 0 when going to LoggedOut (clear cart on logout)
            next(mode) = LoggedOut                    : 0;

            -- while shopping, allow add/remove/idle within bounds
            mode = Shopping & items = 0               : {items + 1, items};
            mode = Shopping & items = 5               : {items - 1, items};
            mode = Shopping & items > 0 & items < 5   : {items - 1, items + 1, items};

            -- otherwise unchanged (e.g., when LoggedOut or CheckedOut)
            TRUE : items;
        esac;
    esac;

    --count logouts
    next(logout_count) := case
        -- count a logout when we move from Shopping to LoggedOut
        mode = Shopping & next(mode) = LoggedOut & logout_count < 5 : logout_count + 1;
        mode = Shopping & next(mode) = LoggedOut & logout_count = 5 : 5;
        TRUE : logout_count;
    esac;

    --Tracking maximum cart size seen so far
    next(max_items) :=case
        next(items) > max_items : next(items);  -- monotone: keep the max
        TRUE : max_items;
    esac;
    -- Detect Add/Remove, alternations and remove-after-add
    next(last_action) := case
      is_checkout | is_logout : None;     -- checkout/logout are not Add/Remove
      is_add                  : Add;
      is_remove               : Remove;
      TRUE                    : None;
    esac;

    -- Count alternations (cap at 2)
    next(alt_steps) := case
      (last_action = Add & is_remove) | (last_action = Remove & is_add) :
        case alt_steps < 2 : alt_steps + 1; TRUE : 2; esac;
      TRUE : alt_steps;
    esac;

    -- Have we ever added?
    next(seen_add) := case
      is_add : TRUE;
      TRUE   : seen_add;
    esac;

    -- Have we ever removed?
    next(removed_ever) := case
      is_remove : TRUE;
      TRUE      : removed_ever;
    esac;

    -- Have we removed at least once after an Add occurred earlier?
    next(removed_after_add) := case
      seen_add & is_remove : TRUE;
      TRUE                 : removed_after_add;
    esac;
    
DEFINE
-- step classifications for helpers (treat only Shopping→Shopping deltas as add/remove)
    is_checkout := (mode = Shopping & next(mode) = CheckedOut);
    is_logout   := (mode = Shopping & next(mode) = LoggedOut);
    is_add    := (mode = Shopping) & (next(mode) = Shopping) & (next(items) = items + 1);
    is_remove := (mode = Shopping) & (next(mode) = Shopping) & (next(items) = items - 1);
-- ST labels (the subsets of AS×AS that define legal steps)
    ST_Login    := (mode = LoggedOut)  & (next(mode) = Shopping);

    ST_Add      := (mode = Shopping)   & (next(mode) = Shopping)
                                   & (next(items) = items + 1) & (items < 5);

    ST_Remove   := (mode = Shopping)   & (next(mode) = Shopping)
                                   & (next(items) = items - 1) & (items > 0);

    ST_Checkout := (mode = Shopping)   & (items > 0)               & (next(mode) = CheckedOut);

    ST_Logout   := (mode = Shopping)   & (next(mode) = LoggedOut);
-- When we drive the system with 'act', which ST label are we choosing?
chosen_ST :=
  case
    act = Login       : ST_Login;
    act = AddAct      : ST_Add;
    act = RemoveAct   : ST_Remove;
    act = CheckoutAct : ST_Checkout;
    act = LogoutAct   : ST_Logout;
    TRUE              : TRUE;  -- Idle means "no step taken"; not constraining
  esac;

  -- Group A: number of logouts before checkout (exact buckets)
A1_no_logout := (logout_count = 0);
A2_one_logout := (logout_count = 1);
A3_two_or_more_logouts := (logout_count >= 2);

  -- Group B: maximum cart size bucket
B1_always_empty := (max_items = 0);
B2_one_to_two   := (max_items >= 1 & max_items <= 2);
B3_three_or_more := (max_items >= 3);

  -- Group C: remove/add behavior
C1_no_remove         := !removed_ever;
C2_remove_after_add  := removed_after_add;     -- at least one remove that was preceded by an add
C3_alt_ge_2          := (alt_steps = 2);       -- two or more alternations    
   
-- If we are in scripted mode and we actually try to take a non-idle action,
-- it must be a legal ST step from the current abstract state.
TRANS ( !USE_SCRIPT ) | (act = Idle) | chosen_ST
-- Before the first checkout, profiles forbid certain ST labels
TRANS (selA1 & !checked_once & !USE_SCRIPT) -> !ST_Logout
TRANS (selB1 & !checked_once & !USE_SCRIPT) -> !ST_Add
TRANS (selC1 & !checked_once & !USE_SCRIPT) -> !ST_Remove
-- A group (pick exactly one per run when you want to characterize the scenario)
--LTLSPEC G (mode = CheckedOut -> A1_no_logout)
-- LTLSPEC G (mode = CheckedOut -> A2_one_logout)
-- LTLSPEC G (mode = CheckedOut -> A3_two_or_more_logouts)

-- B group (pick exactly one)
--LTLSPEC G (mode = CheckedOut -> B1_always_empty)
-- LTLSPEC G (mode = CheckedOut -> B2_one_to_two)
-- LTLSPEC G (mode = CheckedOut -> B3_three_or_more)

-- C group (pick exactly one)
--LTLSPEC G (mode = CheckedOut -> C1_no_remove)
-- LTLSPEC G (mode = CheckedOut -> C2_remove_after_add)
-- LTLSPEC G (mode = CheckedOut -> C3_alt_ge_2)


LTLSPEC F (mode = CheckedOut)


-- If unscripted and selB1 before first checkout, cart never grows:
LTLSPEC G ( !USE_SCRIPT & selB1 & !checked_once -> items = 0 )

-- If unscripted and selA1 before first checkout, there’s no Shopping->LoggedOut edge:
LTLSPEC G ( !USE_SCRIPT & selA1 & !checked_once -> !(mode = Shopping & X mode = LoggedOut) )