1. procedure CTD_TLP_TEST_GENERATION (model_file, factors_file):

# 1. Load configuration (JSON factors & SMV file)
config      <- LOAD_CONFIGURATION (model_file, factors_file)
factors     <- config.factors                              # factor - value domain
all_pairs   <- COMPUTE_ALL_PAIRS(factors)                  # set of (factor, value) pairs

#2. Initialize global sets      
feasible_pairs      <- []                                  # proven satisfiable (locally or via rows)
covered_pairs       <- []                                  # pairs that appeared in a feasible full-row test
infeasible_pairs    <- []                                  # pairs proven as impossible

test_suite          <- []                                  # list of feasible rows (full configuration)

#3. Phase 1 - Static pairwise rows (IPO style)
base_rows           <- CTD_PAIRWISE_GENERATE (factors)

(feasible_pairs,
 covered_pairs,
 infeasible_pairs,
 test_suite)        <- PHASE1_ROWS (base_rows,
                                    config,
                                    feasible_pairs,
                                    covered_pairs,
                                    infeasible_pairs,
                                    test_suite)

#4. Phase 2 - Dynamic completion of missing pairs
(feasible_pairs,
 covered_pairs,
 infeasible_pairs,
 test_suite)        <- PHASE2_DYNAMIC_COMPLETION (all_pairs,
                                                  config,
                                                  feasible_pairs,
                                                  covered_pairs,
                                                  infeasible_pairs,
                                                  test_suite)

#5. Return final artifacts
return{
    feasible_pairs,
    covered_pairs,
    infeasible_pairs,
    test_suite
}

2. Phase 1 - Static Pairwise Rows + Row Oracle + Pair Oracle (run_ipo_with_oracle):

procedure PHASE1_ROWS(base_rows,
                      config,
                      feasible_pairs,
                      covered_pairs,
                      infeasible_pairs,
                      test_suite):

    for each row in base_rows:

        # 1. Encode row as a single global LTL requirement phi_row
        phi_row         <- ENCODE_ROW_TO_LTL(row, config)

        # 2. Ask nuXmv if there exist test steps satisfying this row
        result          <- ORACLE_ROW_FEASIBLE(phi_row, config)

        if result == FEASIBLE:
            # 2.a The row is globally feasible - we get the concrete test steps.
            test_suite.add(row)
            SAVE_TRACE_FOR_ROW(row, config)

            pairs_in_row    <- EXTRACT_PAIRS(row)
            feasible_pairs  <- feasible_pairs U pairs_in_row
            covered_pairs   <- covered_pairs  U pairs_in_row

        else
            # 2.b The row is globally infeasible - we refine using pair-level Oracle
            (infeasible_pair, newly_feasible_pairs)     <- 
                PAIR_LEVEL_ORACLE(row,
                                config,
                                infeasible_pairs)

            if infeasible_pair != NONE:
                infeasible_pairs    <- infeasible_pairs U {infeasible_pair}

            feasible_pairs          <- feasible_pairs   U newly_feasible_pairs
    
    return (feasible_pairs, covered_pairs, infeasible_pairs, test_suite)


3. Phase 2 - Dynamic Completion of Uncovered Pairs (run_ipo_with_oracle):

procedure PHASE2_DYNAMIC_COMPLETION(all_pairs,
                                    config,
                                    feasible_pairs,
                                    covered_pairs,
                                    infeasible_pairs,
                                    test_suite):
    
    while TRUE:

        target_pairs            <- all pairs - covered_pairs - infeasible_pairs
        if target_pairs is empty:
            break   #all pairs are either covered or proven infeasible
        
        # 1. select one uncovered + unknown pair to investigate
        pair                    <- SELECT_NEXT_TARGET_PAIR(target_pairs, feasible_pairs, covered_pairs)

        # 2. Try to construct a full row with all possible parameters around this pair,
        # avoiding any know infeasible pairs
        row                     <- TRY_BUILD_ROW_AROUND_PAIR(pair, config, infeasible_pairs)

        if row == NONE:
            # no consistent row exists that contains this pair
            infeasible_pairs    <- infeasible_pairs U {pair}
            continue

        # 3. Check the constructed row using the row oracle
        phi_row                 <- ENCODE_ROW_TO_LTL(row, config)
        result                  <- ORACLE_ROW_FEASIBLE(phi_row, config)

        if result == FEASIBLE:
            # 3.a The row is feasible: we add real test steps
            test_suite.add(row)
            SAVE_TRACE_FOR_ROW(row,config)

            pairs_in_row        <- EXTRACT_PAIRS(row)
            feasible_pairs      <- feasible_pairs U pairs_in_row
            covered_pairs       <- covered_pairs  U pairs_in_row

        else:
            # 3.b The row is infeasible: refine by finding the first bad pair
            (infeasible_pair, newly_feasible_pairs) <- 
                PAIR_LEVEL_ORACLE (row,
                                   config,
                                   infeasible_pairs)
            
            if infeasible_pair != NONE:
                infeasible_pairs    <- infeasible_pairs U {infeasible_pair}

            feasible_pairs          <- feasible_pairs   U newly_feasible_pairs

    return (feasible_pairs, covered_pairs, infeasible_pairs, test_suite)


4. Building a Row Around a Target Pair

procedure TRY_BUILD_ROW_AROUND_PAIR(target_pair, config, infeasible_pairs):
    row <-PARTIAL_ASSIGNMENT_WITH(target_pair)

    #factors not yet assigned
    remaining_factors   <- ALL_FACTORS(config) - FACTORS_IN(row)

    for each factor f in ORDER_FACTORS(remaining_factors):

        candidate_values    <- DOMAIN(f, config)

        value_chosen        <- NONE

        for each v in candidate_values:

            temp_row        <- row U {(f, v)}

            if CONTAINS_KNOWN_INFEASIBLE_PAIR(temp_row, infeasible_pairs):
                continue    #skip combinations already known as impossible
        
        if value_chosen = NONE:
            #no value for f can extend the row without violating known constraints
            return NONE

        row                 <- row U {(f, value_chosen)}

    return row              #completed full configuration including target_pair


    5. Row-Level Oracle (nuXmv)

    function ORACLE_ROW_FEASIBLE(phi_row, config):

        # How it is implemented:
        # We check the negation of phi_row in nuXmv: check_ltlspec -p "!phi_row"
        #
        # if !phi_row is FALSE   -> no behavior violates phi_row                 -> row is FEASIBLE.
        # if !phi_row is TRUE    -> there exists a behavior violating phi_row    -> row is INFEASIBLE.

        result  <- NUXMV_CHECK_NEGATED(phi_row, config)

        if result == UNSAT:
            return FEASIBLE
        else:
            return INFEASIBLE



6. Pair-Level Oracle
procedure PAIR_LEVEL_ORACLE(row, config, infeasible_pairs):

    newly_feasible_pairs        <- []

    ordered_pairs               <- ORDER_PAIRS(EXTRACT_PAIRS(row))

    for each pair in ordered_pairs:
        
        if pair in infeasible_pairs:
            continue    #already known impossible

        status  <- CHECK_PAIR_FEASIBILITY(pair, config)

        if status == INFEASIBLE:
            #first pair cannot appear in any trace
            return (pair, newly_feasible_pairs)

        if status == FEASIBLE:
            newly_feasible_pairs    <- newly_feasible_pairs U {pair}

    # no single pair was identified as infeasible; row was infeasible
    # due to higher-order interaction or global constraint 
    return (NONE, newly_feasible_pairs)



7. Pair Feasiblity via Local Oracle

function CHECK_PAIR_FEASIBILITY(pair, config):

    #Build a partial configuration that makes the following pair.
    partial_row <- PARTIAL_ASSIGNMENT_WITH(pair)

    #Encode the existence of a behavior that satisfies "partial_row"
    phi_pair    <- ENCODE_PARTIAL_TO_LTL(partial_row, config)

    result      <- ORACLE_ROW_FEASIBLE(phi_pair, config)

    if result == FEASIBLE:
        return FEASIBLE
    else:
        return INFEASIBLE
        

    
